"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Nathan Rajlich, Félicien François, Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyAgent = exports.ProxyAgent0 = exports.createTlsPatch = exports.createHttpPatch = exports.createProxyResolver = exports.LogLevel = void 0;
var http = __importStar(require("http"));
var nodeurl = __importStar(require("url"));
var os = __importStar(require("os"));
var fs = __importStar(require("fs"));
var cp = __importStar(require("child_process"));
var http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
var https_proxy_agent_1 = __importDefault(require("https-proxy-agent"));
var debug_1 = __importDefault(require("debug"));
var SocksProxyAgent = require('socks-proxy-agent');
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warning"] = 3] = "Warning";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Critical"] = 5] = "Critical";
    LogLevel[LogLevel["Off"] = 6] = "Off";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var maxCacheEntries = 5000; // Cache can grow twice that much due to 'oldCache'.
function createProxyResolver(params) {
    var getHttpProxySetting = params.getHttpProxySetting, log = params.log, getLogLevel = params.getLogLevel, proxyResolverTelemetry = params.proxyResolveTelemetry, useHostProxy = params.useHostProxy, env = params.env;
    var envProxy = proxyFromConfigURL(env.https_proxy || env.HTTPS_PROXY || env.http_proxy || env.HTTP_PROXY); // Not standardized.
    var envNoProxy = noProxyFromEnv(env.no_proxy || env.NO_PROXY); // Not standardized.
    var cacheRolls = 0;
    var oldCache = new Map();
    var cache = new Map();
    function getCacheKey(url) {
        // Expecting proxies to usually be the same per scheme://host:port. Assuming that for performance.
        return nodeurl.format(__assign(__assign({}, url), { pathname: undefined, search: undefined, hash: undefined }));
    }
    function getCachedProxy(key) {
        var proxy = cache.get(key);
        if (proxy) {
            return proxy;
        }
        proxy = oldCache.get(key);
        if (proxy) {
            oldCache.delete(key);
            cacheProxy(key, proxy);
        }
        return proxy;
    }
    function cacheProxy(key, proxy) {
        cache.set(key, proxy);
        if (cache.size >= maxCacheEntries) {
            oldCache = cache;
            cache = new Map();
            cacheRolls++;
            log(LogLevel.Debug, 'ProxyResolver#cacheProxy cacheRolls', cacheRolls);
        }
    }
    var timeout;
    var count = 0;
    var duration = 0;
    var errorCount = 0;
    var cacheCount = 0;
    var envCount = 0;
    var settingsCount = 0;
    var localhostCount = 0;
    var envNoProxyCount = 0;
    var results = [];
    function logEvent() {
        timeout = undefined;
        proxyResolverTelemetry({ count: count, duration: duration, errorCount: errorCount, cacheCount: cacheCount, cacheSize: cache.size, cacheRolls: cacheRolls, envCount: envCount, settingsCount: settingsCount, localhostCount: localhostCount, envNoProxyCount: envNoProxyCount, results: results });
        count = duration = errorCount = cacheCount = envCount = settingsCount = localhostCount = envNoProxyCount = 0;
        results = [];
    }
    function resolveProxy(flags, req, opts, url, callback) {
        if (!timeout) {
            timeout = setTimeout(logEvent, 10 * 60 * 1000);
        }
        var stackText = getLogLevel() === LogLevel.Trace ? '\n' + new Error('Error for stack trace').stack : '';
        useSystemCertificates(params, flags.useSystemCertificates, opts, function () {
            useProxySettings(useHostProxy, flags.useProxySettings, req, opts, url, stackText, callback);
        });
    }
    function useProxySettings(useHostProxy, useProxySettings, req, opts, url, stackText, callback) {
        if (!useProxySettings) {
            callback('DIRECT');
            return;
        }
        var parsedUrl = nodeurl.parse(url); // Coming from Node's URL, sticking with that.
        var hostname = parsedUrl.hostname;
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1' || hostname === '::ffff:127.0.0.1') {
            localhostCount++;
            callback('DIRECT');
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy localhost', url, 'DIRECT', stackText);
            return;
        }
        if (typeof hostname === 'string' && envNoProxy(hostname, String(parsedUrl.port || opts.agent.defaultPort))) {
            envNoProxyCount++;
            callback('DIRECT');
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy envNoProxy', url, 'DIRECT', stackText);
            return;
        }
        var settingsProxy = proxyFromConfigURL(getHttpProxySetting());
        if (settingsProxy) {
            settingsCount++;
            callback(settingsProxy);
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy settings', url, settingsProxy, stackText);
            return;
        }
        if (envProxy) {
            envCount++;
            callback(envProxy);
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy env', url, envProxy, stackText);
            return;
        }
        var key = getCacheKey(parsedUrl);
        var proxy = getCachedProxy(key);
        if (proxy) {
            cacheCount++;
            collectResult(results, proxy, parsedUrl.protocol === 'https:' ? 'HTTPS' : 'HTTP', req);
            callback(proxy);
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy cached', url, proxy, stackText);
            return;
        }
        if (!useHostProxy) {
            callback('DIRECT');
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy unconfigured', url, 'DIRECT', stackText);
            return;
        }
        var start = Date.now();
        params.resolveProxy(url) // Use full URL to ensure it is an actually used one.
            .then(function (proxy) {
            if (proxy) {
                cacheProxy(key, proxy);
                collectResult(results, proxy, parsedUrl.protocol === 'https:' ? 'HTTPS' : 'HTTP', req);
            }
            callback(proxy);
            log(LogLevel.Debug, 'ProxyResolver#resolveProxy', url, proxy, stackText);
        }).then(function () {
            count++;
            duration = Date.now() - start + duration;
        }, function (err) {
            errorCount++;
            callback();
            log(LogLevel.Error, 'ProxyResolver#resolveProxy', toErrorMessage(err), stackText);
        });
    }
    return resolveProxy;
}
exports.createProxyResolver = createProxyResolver;
function collectResult(results, resolveProxy, connection, req) {
    var proxy = resolveProxy ? String(resolveProxy).trim().split(/\s+/, 1)[0] : 'EMPTY';
    req.on('response', function (res) {
        var code = "HTTP_" + res.statusCode;
        var result = findOrCreateResult(results, proxy, connection, code);
        result.count++;
    });
    req.on('error', function (err) {
        var code = err && typeof err.code === 'string' && err.code || 'UNKNOWN_ERROR';
        var result = findOrCreateResult(results, proxy, connection, code);
        result.count++;
    });
}
function findOrCreateResult(results, proxy, connection, code) {
    for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
        var result_1 = results_1[_i];
        if (result_1.proxy === proxy && result_1.connection === connection && result_1.code === code) {
            return result_1;
        }
    }
    var result = { proxy: proxy, connection: connection, code: code, count: 0 };
    results.push(result);
    return result;
}
function proxyFromConfigURL(configURL) {
    if (!configURL) {
        return undefined;
    }
    var url = (configURL || '').trim();
    var i = url.indexOf('://');
    if (i === -1) {
        return undefined;
    }
    var scheme = url.substr(0, i).toLowerCase();
    var proxy = url.substr(i + 3);
    if (scheme === 'http') {
        return 'PROXY ' + proxy;
    }
    else if (scheme === 'https') {
        return 'HTTPS ' + proxy;
    }
    else if (scheme === 'socks') {
        return 'SOCKS ' + proxy;
    }
    return undefined;
}
function noProxyFromEnv(envValue) {
    var value = (envValue || '')
        .trim()
        .toLowerCase();
    if (value === '*') {
        return function () { return true; };
    }
    var filters = value
        .split(',')
        .map(function (s) { return s.trim().split(':', 2); })
        .map(function (_a) {
        var name = _a[0], port = _a[1];
        return ({ name: name, port: port });
    })
        .filter(function (filter) { return !!filter.name; })
        .map(function (_a) {
        var name = _a.name, port = _a.port;
        var domain = name[0] === '.' ? name : "." + name;
        return { domain: domain, port: port };
    });
    if (!filters.length) {
        return function () { return false; };
    }
    return function (hostname, port) { return filters.some(function (_a) {
        var domain = _a.domain, filterPort = _a.port;
        return ("." + hostname.toLowerCase()).endsWith(domain) && (!filterPort || port === filterPort);
    }); };
}
function createHttpPatch(originals, resolveProxy, proxySetting, certSetting, onRequest) {
    return {
        get: patch(originals.get),
        request: patch(originals.request)
    };
    function patch(original) {
        function patched(url, options, callback) {
            if (typeof url !== 'string' && !(url && url.searchParams)) {
                callback = options;
                options = url;
                url = null;
            }
            if (typeof options === 'function') {
                callback = options;
                options = null;
            }
            options = options || {};
            if (options.socketPath) {
                return original.apply(null, arguments);
            }
            var originalAgent = options.agent;
            if (originalAgent === true) {
                throw new Error('Unexpected agent option: true');
            }
            var isHttps = originals.globalAgent.protocol === 'https:';
            var optionsPatched = originalAgent instanceof exports.ProxyAgent;
            var config = onRequest && (options._vscodeProxySupport || /* LS */ options._vscodeSystemProxy) || proxySetting.config;
            var useProxySettings = !optionsPatched && (config === 'override' || config === 'on' && originalAgent === undefined);
            var useSystemCertificates = !optionsPatched && certSetting.config && isHttps && !options.ca;
            if (useProxySettings || useSystemCertificates) {
                if (url) {
                    var parsed = typeof url === 'string' ? new nodeurl.URL(url) : url;
                    var urlOptions = {
                        protocol: parsed.protocol,
                        hostname: parsed.hostname.lastIndexOf('[', 0) === 0 ? parsed.hostname.slice(1, -1) : parsed.hostname,
                        port: parsed.port,
                        path: "" + parsed.pathname + parsed.search
                    };
                    if (parsed.username || parsed.password) {
                        options.auth = parsed.username + ":" + parsed.password;
                    }
                    options = __assign(__assign({}, urlOptions), options);
                }
                else {
                    options = __assign({}, options);
                }
                options.agent = new exports.ProxyAgent({
                    resolveProxy: resolveProxy.bind(undefined, { useProxySettings: useProxySettings, useSystemCertificates: useSystemCertificates }),
                    defaultPort: isHttps ? 443 : 80,
                    originalAgent: originalAgent,
                });
                return original(options, callback);
            }
            return original.apply(null, arguments);
        }
        return patched;
    }
}
exports.createHttpPatch = createHttpPatch;
function createTlsPatch(originals) {
    return {
        createSecureContext: patch(originals.createSecureContext)
    };
    function patch(original) {
        return function (details) {
            var context = original.apply(null, arguments);
            var certs = details._vscodeAdditionalCaCerts;
            if (certs) {
                for (var _i = 0, certs_1 = certs; _i < certs_1.length; _i++) {
                    var cert = certs_1[_i];
                    context.context.addCACert(cert);
                }
            }
            return context;
        };
    }
}
exports.createTlsPatch = createTlsPatch;
function useSystemCertificates(params, useSystemCertificates, opts, callback) {
    if (useSystemCertificates) {
        getCaCertificates(params)
            .then(function (caCertificates) {
            if (caCertificates) {
                if (caCertificates.append) {
                    opts._vscodeAdditionalCaCerts = caCertificates.certs;
                }
                else {
                    opts.ca = caCertificates.certs;
                }
            }
            callback();
        })
            .catch(function (err) {
            params.log(LogLevel.Error, 'ProxyResolver#useSystemCertificates', toErrorMessage(err));
        });
    }
    else {
        callback();
    }
}
var _caCertificates;
function getCaCertificates(_a) {
    var log = _a.log;
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_b) {
            if (!_caCertificates) {
                _caCertificates = readCaCertificates()
                    .then(function (res) {
                    log(LogLevel.Debug, 'ProxyResolver#getCaCertificates count', res && res.certs.length);
                    return res && res.certs.length ? res : undefined;
                })
                    .catch(function (err) {
                    log(LogLevel.Error, 'ProxyResolver#getCaCertificates error', toErrorMessage(err));
                    return undefined;
                });
            }
            return [2 /*return*/, _caCertificates];
        });
    });
}
function readCaCertificates() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (process.platform === 'win32') {
                return [2 /*return*/, readWindowsCaCertificates()];
            }
            if (process.platform === 'darwin') {
                return [2 /*return*/, readMacCaCertificates()];
            }
            if (process.platform === 'linux') {
                return [2 /*return*/, readLinuxCaCertificates()];
            }
            return [2 /*return*/, undefined];
        });
    });
}
function readWindowsCaCertificates() {
    return __awaiter(this, void 0, void 0, function () {
        var winCA, ders, store, der, certs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.resolve().then(function () { return __importStar(require('vscode-windows-ca-certs')); })];
                case 1:
                    winCA = _a.sent();
                    ders = [];
                    store = new winCA.Crypt32();
                    try {
                        der = void 0;
                        while (der = store.next()) {
                            ders.push(der);
                        }
                    }
                    finally {
                        store.done();
                    }
                    certs = new Set(ders.map(derToPem));
                    return [2 /*return*/, {
                            certs: Array.from(certs),
                            append: true
                        }];
            }
        });
    });
}
function readMacCaCertificates() {
    return __awaiter(this, void 0, void 0, function () {
        var stdout, certs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                        var child = cp.spawn('/usr/bin/security', ['find-certificate', '-a', '-p']);
                        var stdout = [];
                        child.stdout.setEncoding('utf8');
                        child.stdout.on('data', function (str) { return stdout.push(str); });
                        child.on('error', reject);
                        child.on('exit', function (code) { return code ? reject(code) : resolve(stdout.join('')); });
                    })];
                case 1:
                    stdout = _a.sent();
                    certs = new Set(stdout.split(/(?=-----BEGIN CERTIFICATE-----)/g)
                        .filter(function (pem) { return !!pem.length; }));
                    return [2 /*return*/, {
                            certs: Array.from(certs),
                            append: true
                        }];
            }
        });
    });
}
var linuxCaCertificatePaths = [
    '/etc/ssl/certs/ca-certificates.crt',
    '/etc/ssl/certs/ca-bundle.crt',
];
function readLinuxCaCertificates() {
    return __awaiter(this, void 0, void 0, function () {
        var _i, linuxCaCertificatePaths_1, certPath, content, certs, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _i = 0, linuxCaCertificatePaths_1 = linuxCaCertificatePaths;
                    _a.label = 1;
                case 1:
                    if (!(_i < linuxCaCertificatePaths_1.length)) return [3 /*break*/, 6];
                    certPath = linuxCaCertificatePaths_1[_i];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, fs.promises.readFile(certPath, { encoding: 'utf8' })];
                case 3:
                    content = _a.sent();
                    certs = new Set(content.split(/(?=-----BEGIN CERTIFICATE-----)/g)
                        .filter(function (pem) { return !!pem.length; }));
                    return [2 /*return*/, {
                            certs: Array.from(certs),
                            append: false
                        }];
                case 4:
                    err_1 = _a.sent();
                    if (err_1.code !== 'ENOENT') {
                        throw err_1;
                    }
                    return [3 /*break*/, 5];
                case 5:
                    _i++;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/, undefined];
            }
        });
    });
}
function derToPem(blob) {
    var lines = ['-----BEGIN CERTIFICATE-----'];
    var der = blob.toString('base64');
    for (var i = 0; i < der.length; i += 64) {
        lines.push(der.substr(i, 64));
    }
    lines.push('-----END CERTIFICATE-----', '');
    return lines.join(os.EOL);
}
function toErrorMessage(err) {
    return err && (err.stack || err.message) || String(err);
}
var debugLog = debug_1.default('vscode-proxy-agent');
var ProxyAgent0 = /** @class */ (function () {
    function ProxyAgent0(session) {
        this.session = session;
        this.addRequest = addRequest;
        if (!(this instanceof ProxyAgent0))
            return new ProxyAgent0(session);
        this.defaultPort = session.defaultPort;
    }
    return ProxyAgent0;
}());
exports.ProxyAgent0 = ProxyAgent0;
function addRequest(req, opts) {
    var url;
    var self = this;
    // calculate the `url` parameter
    var defaultAgent = opts._defaultAgent || http.globalAgent;
    var path = req.path;
    var firstQuestion = path.indexOf('?');
    var search;
    if (-1 != firstQuestion) {
        search = path.substring(firstQuestion);
        path = path.substring(0, firstQuestion);
    }
    url = nodeurl.format(Object.assign({}, opts, {
        protocol: defaultAgent.protocol,
        pathname: path,
        search: search,
        // need to use `hostname` instead of `host` otherwise `port` is ignored
        hostname: opts.host,
        host: null,
        // set `port` to null when it is the protocol default port (80 / 443)
        port: defaultAgent.defaultPort == opts.port ? null : opts.port
    }));
    debugLog('url: %o', url);
    self.session.resolveProxy(req, opts, url, onproxy);
    // `resolveProxy()` callback function
    function onproxy(proxy) {
        // default to "DIRECT" if a falsey value was returned (or nothing)
        if (!proxy)
            proxy = 'DIRECT';
        var proxies = String(proxy).trim().split(/\s*;\s*/g).filter(Boolean);
        // XXX: right now, only the first proxy specified will be used
        var first = proxies[0];
        debugLog('using proxy: %o', first);
        var agent;
        var parts = first.split(/\s+/);
        var type = parts[0];
        if ('DIRECT' == type) {
            // direct connection to the destination endpoint
            agent = getDirectAgent(self.session.originalAgent, defaultAgent);
        }
        else if ('SOCKS' == type) {
            // use a SOCKS proxy
            agent = new SocksProxyAgent('socks://' + parts[1]);
        }
        else if ('PROXY' == type || 'HTTPS' == type) {
            // use an HTTP or HTTPS proxy
            // http://dev.chromium.org/developers/design-documents/secure-web-proxy
            var proxyURL = ('HTTPS' === type ? 'https' : 'http') + '://' + parts[1];
            var proxy_1 = nodeurl.parse(proxyURL);
            if (defaultAgent.protocol === 'https:') {
                agent = new https_proxy_agent_1.default(proxy_1);
            }
            else {
                agent = new http_proxy_agent_1.default(proxy_1);
            }
        }
        else {
            // direct connection to the destination endpoint
            agent = getDirectAgent(self.session.originalAgent, defaultAgent);
        }
        agent.addRequest(req, opts);
    }
}
function getDirectAgent(originalAgent, defaultAgent) {
    if (originalAgent === false) {
        return new defaultAgent.constructor();
    }
    return originalAgent || defaultAgent;
}
exports.ProxyAgent = ProxyAgent0;